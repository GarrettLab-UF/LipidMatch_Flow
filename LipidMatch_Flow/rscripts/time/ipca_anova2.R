#########################################################
## R script for MetaboAnalyst
## Description: perform two-way within/between subjects ANOVA
##
## Author: Jeff Xia, jeff.xia@mcgill.ca
## McGill University, Canada
##
## License: GNU GPL (>= 2)
###################################################

###############################################
################ Two-way ANOVA ################
###############################################

# perform within-subjects anova
aov.within <- function(x, time.fac) {
   unlist(summary(aov(x ~ (dataSet$facA*dataSet$facB) + Error(dataSet$sbj/time.fac))), use.names=F)[c(9,23,24)];
}

# repeated measure one-way anova
aov.repeated <- function(x, time.fac) {
   unlist(summary(aov(x ~ time.fac + Error(dataSet$sbj/time.fac))), use.names=F)[c(12,14)];
}

# perform between-subjects anova
aov.between <- function(x) {
   unlist(summary(aov(x ~ dataSet$facA*dataSet$facB)), use.names=F)[c(17,18,19)];
}

# p.value corrrection - bonferroni, holm, fdr,
# type b for between subjects, w for within
ANOVA2.Anal<-function(thresh=0.05, p.cor="fdr", type="time0"){
    if(type == "time0"){
        time.fac <- dataSet$time.fac;
        dataSet$sbj <<- as.factor(dataSet$exp.fac);

        # first create the subjects that being measured under different time
        # points (under same phenotype/ exp. condition). The design must be balanced

        # first check if balanced
        res <- table (time.fac, dataSet$sbj);
        res.mean <- apply(res, 2, mean);
        all.res <- res/res.mean;
        if(sum(all.res != 1) > 0){
            msg <- "Experiment design is not balanced!";
            AddErrMsg(msg);
            print(msg);
            return(0);
        }

        aov.mat<-t(apply(as.matrix(dataSet$norm), 2, aov.repeated, time.fac));
        fileName <- "oneway_anova_repeated.csv";
        rownames(aov.mat)<-colnames(dataSet$norm);
        aov.mat <- cbind(aov.mat, p.adjust(aov.mat[,2], p.cor));
        colnames(aov.mat) <- c("F-value", "Raw P-val", "Adjusted P-val");
        p.value <- aov.mat[,3];
        inx.imp <-aov.mat[,3] <= thresh;
        aov.mat <- aov.mat[inx.imp, ,drop=F];
        vennC <- NULL;
        # default sort first by main effect: treatment, then by ...
        ord.inx <- order(aov.mat[,2], decreasing = FALSE);
    }else{
        if(type=="time"){
            # first create the subjects that being measured under different time
            # points (under same phenotype/ exp. condition). The design must be balanced

            # first check if balanced
            res <- table (dataSet$facA, dataSet$facB);
            res.mean <- apply(res, 2, mean);
            all.res <- res/res.mean;
            if(sum(all.res != 1) > 0){
                msg <- "Experiment design is not balanced!";
                AddErrMsg(msg);
                print(msg);
                return(0);
            }
            time.fac <- dataSet$time.fac;
            exp.fac <- dataSet$exp.fac;

            sbj <- vector(mode="character", length=nrow(dataSet$norm));
            k = 1;
            len = 0;
            for(lv1 in levels(exp.fac)){
                # same subjects must in the same exp. condition
                inx1 <- exp.fac == lv1;
                for (lv2 in levels(time.fac)){
                    inx2 <- time.fac == lv2;
                    len <- sum(inx1 & inx2);

                    # same subjects must not in the same time points
                    # so in a balanced design and ordered by the time points
                    # all samples in each time points will sweep all subjects (one go)
                    sbj[inx1 & inx2] <- paste("S", k:(k+len-1), sep="");
                }
                k = k + len;
            }

            dataSet$sbj <<- as.factor(sbj);
            aov.mat<-t(apply(as.matrix(dataSet$norm), 2, aov.within, time.fac));
            fileName <- "anova_within_sbj.csv";
        }else{
            aov.mat<-t(apply(as.matrix(dataSet$norm), 2, aov.between));
            fileName <- "anova_between_sbj.csv";
        }
        rownames(aov.mat)<-colnames(dataSet$norm);

        if(p.cor != "none"){
            aov.mat <- cbind (p.adjust(aov.mat[,1], p.cor),
                          p.adjust(aov.mat[,2], p.cor),
                          p.adjust(aov.mat[,3], p.cor));
        }

        sig.facA <-(aov.mat[,1] <= thresh);
        sig.facB <-(aov.mat[,2] <= thresh);
        sig.intr <-(aov.mat[,3] <= thresh);

        all.match <- cbind(sig.facA, sig.facB, sig.intr);
        colnames(all.match) <- colnames(aov.mat) <- c(dataSet$facA.lbl, dataSet$facB.lbl, "Interaction");

        vennC <- getVennCounts(all.match);
        p.value <- aov.mat[,1]; # not used
        inx.imp <- sig.facA | sig.facB | sig.intr;
        aov.mat <- aov.mat[inx.imp, ,drop=F];

        # default sort first by main effect: treatment, then by ...
        ord.inx <- order(aov.mat[,1], aov.mat[,2], aov.mat[,3], decreasing = FALSE);
    }

    aov.mat <- signif(aov.mat[ord.inx,,drop=F], 5);
    write.csv(aov.mat,file=fileName);

    aov2<-list (
          type = type,
          sig.nm = fileName,
          thresh = -log10(thresh),
          multi.c = p.cor,
          sig.mat = aov.mat,
          p.log = -log10(p.value),
          inx.imp = inx.imp,
          vennC = vennC
      );

    analSet$aov2<<-aov2;
    return(1);
}

# plot ven diagram for ANOVA results
PlotANOVA2<-function(imgName, format="png", dpi=72, width=NA){
    imgName = paste(imgName, "dpi", dpi, ".", format, sep="");
    if(is.na(width)){
        w <- 7;
    }else if(width == 0){
        w <- 7;
        imgSet$anova2<<-imgName;
    }else{
        w <- width;
    }

    if(dataSet$design.type == "time0"){
        w <- 9;
        h <- w*6/9;
        lod <- analSet$aov2$p.log;
        Cairo(file = imgName, unit="in", dpi=dpi, width=w, height=h, type=format, bg="white");
        plot(lod, ylab="-log10(p)", xlab = "Index", main="One-way repeated measures ANOVA", type="n");
        red.inx<- which(analSet$aov2$inx.imp);
        blue.inx <- which(!analSet$aov2$inx.imp);
        points(red.inx, lod[red.inx], bg="red", cex=1.2, pch=21);
        points(blue.inx, lod[blue.inx], bg="green", pch=21);
        abline (h=analSet$aov2$thresh, lty=3);
        dev.off();
    }else{
        h <- w;
        title <- ifelse(analSet$aov2$type == "g2", "Two-way ANOVA (between subjects)", "Two-way ANOVA (within subject)");
        Cairo(file = imgName, unit="in", dpi=dpi, width=w, height=h, type=format, bg="white");
        plotVennDiagram(analSet$aov2$vennC, circle.col=c("red", "blue", "green"), mar=c(0,0,2,0));
        mtext(title, NORTH<-3, line=0.25, cex=1.5);
        dev.off();
    }
}

GetAov2SigFileName <-function(){
    analSet$aov2$sig.nm;
}

GetAov2SigMat<-function(){
   return(CleanNumber(as.matrix(analSet$aov2$sig.mat)));
}

GetAov2SigRowNames<-function(){
    rownames(analSet$aov2$sig.mat);
}

GetAov2SigColNames<-function(){
    colnames(analSet$aov2$sig.mat);
}

GetSigTable.Aov2<-function(){
    GetSigTable(analSet$aov2$sig.mat,
                "Significant features identified by advanced ANOVA");
}

GetAnova2UpMat<-function(){
    lod <- analSet$aov2$p.log;
    red.inx<- which(analSet$aov2$inx.imp);
    as.matrix(cbind(red.inx, lod[red.inx]));
}

GetAnova2DnMat<-function(){
    lod <- analSet$aov$p.log;
    blue.inx <- which(!analSet$aov2$inx.imp);
    as.matrix(cbind(blue.inx, lod[blue.inx]));
}
GetAnova2LnMat<-function(){
    lod <- analSet$aov2$p.log;
    as.matrix(rbind(c(0, analSet$aov2$thresh), c(length(lod)+1,analSet$aov2$thresh)));
}

GetAnova2Cmpds<-function(){
    names(analSet$aov2$p.log);
}

GetMaxAnova2Inx <- function(){
    which.max(analSet$aov2$p.log);
}

# perform PCA analysis, prepare file for interactive liveGraphics3D
iPCA.Anal<-function(fileNm){
    pca<-prcomp(dataSet$norm, center=T, scale=F);
    imp.pca<-summary(pca)$importance;

    pca3d <- list();
    pca3d$score$axis <- paste("PC", 1:3, " (", 100*round(imp.pca[2,][1:3], 3), "%)", sep="");
    coords <- data.frame(t(signif(pca$x[,1:3], 5)));
    colnames(coords) <- NULL; 
    pca3d$score$xyz <- coords;
    pca3d$score$name <- rownames(dataSet$norm);
    facA <- as.character(dataSet$facA);
    if(all.numeric(facA)){
        facA <- paste("Group", facA);
    }
    pca3d$score$facA <- facA;
    facB <- as.character(dataSet$facB);
    if(all.numeric(facB)){
        facB <- paste("Group", facB);
    }
    pca3d$score$facB <- facB;

    pca3d$loadings$axis <- paste("Loadings", 1:3);
    coords <- data.frame(t(signif(pca$rotation[,1:3], 5)));
    colnames(coords) <- NULL; 
    pca3d$loadings$xyz <- coords;
    pca3d$loadings$name <- colnames(dataSet$norm);

    # now set color for each group
    cols <- unique(GetColorSchema());
    rgbcols <- col2rgb(cols);
    cols <- apply(rgbcols, 2, function(x){paste("rgb(", paste(x, collapse=","), ")", sep="")});
    pca3d$score$colors <- cols;

    library(RJSONIO);
    json.obj <- toJSON(pca3d, .na='null');
    sink(fileNm);
    cat(json.obj);
    sink();
}

#	Plot Venn diagram
#	Gordon Smyth, James Wettenhall.
#	Capabilities for multiple counts and colors by Francois Pepin.
#	4 July 2003.  Last modified 12 March 2010.
plotVennDiagram <- function(object,include="both",names,mar=rep(0,4),cex=1.2,lwd=1,circle.col,counts.col,show.include,...){
	if (!is(object, "VennCounts")){
		if (length(include)>2) stop("Cannot plot Venn diagram for more than 2 sets of counts")
		if (length(include)==2) object.2 <- getVennCounts(object, include = include[2])
		object <- getVennCounts(object, include = include[1])
	}
	else if(length(include==2)) include <- include[1]
	nsets <- ncol(object)-1
	if(nsets > 3) stop("Can't plot Venn diagram for more than 3 sets")
	if(missing(names)) names <- colnames(object)[1:nsets]
	counts <- object[,"Counts"]
	if(length(include)==2) counts.2 <- object.2[, "Counts"]
	if(missing(circle.col)) circle.col <- par('col')
	if(length(circle.col)<nsets) circle.col <- rep(circle.col,length.out=nsets)
	if(missing(counts.col)) counts.col <- par('col')
	if(length(counts.col)<length(include)) counts.col <- rep(counts.col,length.out=length(include))
	if(missing(show.include)) show.include <- as.logical(length(include)-1)
	theta <- 2*pi*(0:360)/360
	xcentres <- list(0,c(-1,1),c(-1,1,0))[[nsets]]
	ycentres <- list(0,c(0,0),c(1/sqrt(3),1/sqrt(3),-2/sqrt(3)))[[nsets]]
	r <- c(1.5,1.5,1.5)[nsets]
	xtext <- list(-1.2,c(-1.2,1.2),c(-1.2,1.2,0))[[nsets]]
	ytext <- list(1.8,c(1.8,1.8),c(2.4,2.4,-3))[[nsets]]
	old.par <- par(mar=mar)
	on.exit(par(old.par))
	plot(x=0,y=0,type="n",xlim=c(-4,4),ylim=c(-4,4),xlab="",ylab="",axes=FALSE,...);

    	circle.col <- col2rgb(circle.col) / 255
    	circle.col <- rgb(circle.col[1,], circle.col[2,], circle.col[3,], 0.3)
	for(i in 1:nsets) {
		lines(xcentres[i]+r*cos(theta),ycentres[i]+r*sin(theta),lwd=lwd,col=circle.col[i])
  		polygon(xcentres[i] + r*cos(theta), ycentres[i] + r*sin(theta), col = circle.col[i], border = NULL)
		text(xtext[i],ytext[i],names[i],cex=cex)
	}
	switch(nsets,
		{
			rect(-3,-2.5,3,2.5)
			printing <- function(counts, cex, adj,col,leg){
				text(2.3,-2.1,counts[1],cex=cex,col=col,adj=adj)
				text(0,0,counts[2],cex=cex,col=col,adj=adj)
				if(show.include) text(-2.3,-2.1,leg,cex=cex,col=col,adj=adj)
			}

		}, {
			rect(-3,-2.5,3,2.5)
			printing <- function(counts, cex, adj,col,leg){
				text(2.3,-2.1,counts[1],cex=cex,col=col,adj=adj)
				text(1.5,0.1,counts[2],cex=cex,col=col,adj=adj)
				text(-1.5,0.1,counts[3],cex=cex,col=col,adj=adj)
				text(0,0.1,counts[4],cex=cex,col=col,adj=adj)
				if(show.include) text(-2.3,-2.1,leg,cex=cex,col=col,adj=adj)
			}
		}, {
			rect(-3,-3.5,3,3.3)
			printing <- function(counts, cex, adj,col,leg){
				text(2.5,-3,counts[1],cex=cex,col=col,adj=adj)
				text(0,-1.7,counts[2],cex=cex,col=col,adj=adj)
				text(1.5,1,counts[3],cex=cex,col=col,adj=adj)
				text(.75,-.35,counts[4],cex=cex,col=col,adj=adj)
				text(-1.5,1,counts[5],cex=cex,col=col,adj=adj)
				text(-.75,-.35,counts[6],cex=cex,col=col,adj=adj)
				text(0,.9,counts[7],cex=cex,col=col,adj=adj)
				text(0,0,counts[8],cex=cex,col=col,adj=adj)
				if(show.include) text(-2.5,-3,leg,cex=cex,col=col,adj=adj)
			}
		}
	)
	adj <- c(0.5,0.5)
	if (length(include)==2)
	  adj <- c(0.5,0)
	printing(counts,cex,adj,counts.col[1],include[1])
	if (length(include)==2) printing(counts.2,cex,c(0.5,1),counts.col[2],include[2])
	invisible()
}