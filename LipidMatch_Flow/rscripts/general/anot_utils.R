
doGeneIDMapping <- function(q.vec, org, type){
    #print(type);
    if(type == "symbol"){
        db.path <- paste("../../libs/", org, "/entrez.csv", sep="");
        db.map <-  read.csv(db.path, header=T, as.is=T);
        hit.inx <- match(q.vec, db.map[, "symbol"]);
        entrezs <- db.map[hit.inx, "gene_id"];
        rm(db.map, q.vec);
        gc();
        return(entrezs);
    }else if(type == "entrez"){
        db.path <- paste("../../libs/", org, "/entrez.csv", sep="");
        db.map <-  read.csv(db.path, header=T, as.is=T);
        hit.inx <- match(q.vec, db.map[, "gene_id"]);
        entrezs <- db.map[hit.inx, "gene_id"];
        rm(db.map, q.vec);
        return(entrezs);
    }else{ 
        if(type == "genbank"){
            db.path <- paste("../../libs/", org, "/entrez_gb.rda", sep="");
            load(db.path);
        }else if(type == "refseq"){
            db.path <- paste("../../libs/", org, "/entrez_refseq.csv", sep="");
            db.map <-  read.csv(db.path, header=T, as.is=T);

            # note, ref.seq can have version number which is not in the database
            # need to strip it off NM_001402.5 => NM_001402
            q.mat <- do.call(rbind, strsplit(q.vec, "\\."));
            q.vec <- q.mat[,1];
        }else if(type == "embl"){
            db.path <- paste("../../libs/", org, "/entrez_embl.csv", sep="");
            db.map <-  read.csv(db.path, header=T, as.is=T);
        }else{
            print("Unknown data type");
            return(0);
        }

        hit.inx <- match(q.vec, db.map[, "accession"]);

        entrezs=db.map[hit.inx, "gene_id"];
        rm(db.map, q.vec);
        gc();
        return(entrezs);
        
     }
}

PerformGeneAnnotation <- function(){
    if(!exists("entrez.vec")){
        print("Could not find Entrez ID list!");
        return(0);
    }

    db.path <- paste("../../libs/", inmex.org, "/entrez.csv", sep="");
    gene.map <- read.csv(db.path, header=T, as.is=T);

    hit.inx <- match(entrez.vec, gene.map[, "gene_id"]);
    dat <- cbind(query=entrez.vec, gene.map[hit.inx, c("symbol","name")]);
    write.csv(dat, file="EntrezID2Gene.csv", row.names=F);
    rm(entrez.vec, envir = .GlobalEnv);
    return(1);
}

doEntrez2SymbolMapping <- function(entrez.vec){
    db.path <- paste("../../libs/", inmex.org, "/entrez.csv", sep="");
    gene.map <- read.csv(db.path, header=T, as.is=T);

    hit.inx <- match(entrez.vec, gene.map[, "gene_id"]);
    symbols <- gene.map[hit.inx, "symbol"];

    # NA to character to avoid some issues?
    symbols[is.na(symbols)] <- 'NA';
    return(symbols);
}

doCompoundMapping<-function(cmpd.vec, q.type){
    cmpd.map <- readRDS("../../libs/compound_db.rds");
    if(q.type == "name"){

       # first find exact match to the common compound names
       hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$name));

       # then try to find exact match to synanyms for the remaining unmatched query names one by one
       todo.inx <-which(is.na(hit.inx));
       if(length(todo.inx) > 0){
            # then try to find exact match to synanyms for the remaining unmatched query names one by one
            syn.db <- readRDS("../../libs/syn_nms.rds")
            syns.list <-  syn.db$syns.list;
            for(i in 1:length(syns.list)){
                syns <-  syns.list[[i]];
                hitInx <- match(tolower(cmpd.vec[todo.inx]), tolower(syns));
                hitPos <- which(!is.na(hitInx));
                if(length(hitPos)>0){
                    # record matched ones
                    orig.inx<-todo.inx[hitPos];
                    hit.inx[orig.inx] <- i;
                    # update unmatched list
                    todo.inx<-todo.inx[is.na(hitInx)];
                }
                if(length(todo.inx) == 0) break;
            }
       }
       dat <-  cmpd.map[hit.inx, "kegg"];
    }else{
       if(q.type == "hmdb"){
            hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$hmdb));
       }else if(q.type == "kegg"){ 
            hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$kegg));
       }else if(q.type == "pubchem"){ 
            hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$pubchem));
       }else if(q.type == "chebi"){
            hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$chebi));
       }else if(q.type == "reactome"){ 
            hit.inx <- match(tolower(cmpd.vec), tolower(cmpd.map$reactome));
       }else{
            print("No support for this compound database");
            return(0);
       }  
       dat <-  cmpd.map[hit.inx, "kegg"];
    }
    return (dat);
}

doKEGG2NameMapping <- function(kegg.vec){
    cmpd.map <- readRDS("../../libs/compound_db.rds");
    hit.inx <- match(tolower(kegg.vec), tolower(cmpd.map$kegg));
    nms <- cmpd.map[hit.inx, "name"];
    return(nms);
}