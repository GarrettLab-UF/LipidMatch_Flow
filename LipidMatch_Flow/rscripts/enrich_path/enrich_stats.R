##################################################
## Description: enrichment analysis algorithms
##
## Author: Jeff Xia, jeff.xia@mcgill.ca
## McGill University, Canada
## License: GNU GPL (>= 2)
###################################################

################################################################
# over-representation analysis using hypergeometric tests
# The prob is calculated as obtain the equal or higher number
# of hitss using 1-phyper. Since phyper is cumulative prob,
# to get P(X>=hit.num) => P(X>(hit.num-1))
#############################################################

CalculateHyperScore<-function(){

    # make a clean dataSet$cmpd data based on name mapping
    # only valid hmdb name will be used
    nm.map <- GetFinalNameMap();
    valid.inx <- !(is.na(nm.map$hmdb)| duplicated(nm.map$hmdb));
    ora.vec <- nm.map$hmdb[valid.inx];

    q.size<-length(ora.vec);
    if(is.na(ora.vec) || q.size==0) {
        AddErrMsg("No valid HMDB compound names found!");
        return(0);
    }

    # make a clean metabilite set based on reference metabolome filtering
    if(use.metabo.filter && exists('metabo.filter.hmdb')){
        current.mset <- lapply(current.mset, function(x){x[x %in% metabo.filter.hmdb]})
        filtered.mset <<- current.mset;
    }

    # total uniq cmpds in the current mset lib
    uniq.count <- length(unique(unlist(current.mset, use.names = FALSE)));

    set.size<-length(current.mset);
    if(set.size ==1){
        AddErrMsg("Cannot perform enrichment analysis on a single metabolite set!");
        return(0);
    }

    hits<-lapply(current.mset, function(x){x[x %in% ora.vec]});
    hit.num<-unlist(lapply(hits, function(x) length(x)), use.names = FALSE);

    if(sum(hit.num>0)==0){
        AddErrMsg("No match was found to the selected metabolite set library!");
        return(0);
    }

	set.num<-unlist(lapply(current.mset, length), use.names = FALSE);

	# prepare for the result table
	res.mat<-matrix(NA, nrow=set.size, ncol=6);        
    rownames(res.mat)<-names(current.mset);
    colnames(res.mat)<-c("total", "expected", "hits", "Raw p", "Holm p", "FDR");
	for(i in 1:set.size){
            res.mat[i,1]<-set.num[i];
            res.mat[i,2]<-q.size*(set.num[i]/uniq.count);
            res.mat[i,3]<-hit.num[i];

            # use lower.tail = F for P(X>x)
            # phyper("# of white balls drawn", "# of white balls in the urn", "# of black balls in the urn", "# of balls drawn")
            res.mat[i,4]<-phyper(hit.num[i]-1, set.num[i], uniq.count-set.num[i], q.size, lower.tail=F);
	}

    # adjust for multiple testing problems
    res.mat[,5] <- p.adjust(res.mat[,4], "holm");
    res.mat[,6] <- p.adjust(res.mat[,4], "fdr");

    res.mat <- res.mat[hit.num>0,];

    ord.inx<-order(res.mat[,4]);
    analSet$ora.mat <<- signif(res.mat[ord.inx,],3);
    analSet$ora.hits <<- hits;

    write.csv(analSet$ora.mat, file="msea_ora_result.csv");
    return(1);
}


GetORA.colorBar<-function(){
    len <- nrow(analSet$ora.mat);
    if(len > 50){
        ht.col <- c(substr(heat.colors(50), 0, 7), rep("#FFFFFF", len-50));
    }else{
        # reduce to hex by remove the last character so HTML understand
        ht.col <- substr(heat.colors(len), 0, 7);
    }
    return (ht.col);
}

GetORA.rowNames<-function(){
    nms <- rownames(analSet$ora.mat);
    if(is.null(nms)){
        return("NA");
    }
    return (nms);
}

GetORA.mat<-function(){
    return(analSet$ora.mat);
}

GetORATable<-function(){
    library(xtable);
    res <- analSet$ora.mat;
    if(substr(analSet$type, 0, 4) == 'mset'){
        print(xtable(analSet$ora.mat,align="p{5cm}|l|l|l|l|l|l", display=c("s","d","f","d","E","E","E"), caption="Result from Over Representation Analysis"),
            tabular.environment = "longtable", caption.placement="top", size="\\scriptsize");
    }else{
        rownames(res)<-GetORA.pathNames();
        print(xtable(res,align="p{5cm}|l|l|l|l||ll|l|l", display=c("s","d","f","d","E","E", "E","E", "f"),
            caption="Result from Pathway Analysis"),
            tabular.environment = "longtable", caption.placement="top", size="\\scriptsize");
    }      
}


####################################################
# quantitative enrichment analysis with globaltest
####################################################

CalculateGlobalTestScore<-function(){
    # now, perform the enrichment analysis
    library('globaltest');

	set.size<-length(current.mset);
    if(set.size ==1){
        AddErrMsg("Cannot perform enrichment analysis on a single metabolite sets!");
        return(0);
    }

    # now, need to make a clean dataSet$norm data based on name mapping
    # only contain valid hmdb hit will be used
    nm.map <- GetFinalNameMap();
    valid.inx <- !(is.na(nm.map$hmdb)| duplicated(nm.map$hmdb));
    nm.map <- nm.map[valid.inx,];
    orig.nms <- nm.map$query;

    hmdb.inx <- match(colnames(dataSet$norm),orig.nms);
    hit.inx <- !is.na(hmdb.inx);
    msea.data<-dataSet$norm[,hit.inx];
    colnames(msea.data) <- nm.map$hmdb[hmdb.inx[hit.inx]];

    # make a clean metabilite set based on reference metabolome filtering
    if(use.metabo.filter && exists('metabo.filter.hmdb')){
        current.mset <- lapply(current.mset, function(x){x[x %in% metabo.filter.hmdb]})
        filtered.mset <<- current.mset;
    }

    # first, get the matched entries from current.mset
    hits<-lapply(current.mset, function(x){x[x %in% colnames(msea.data)]});

    phenotype <- dataSet$cls;

    # this step is very slow
    gt.obj <- gt(phenotype, msea.data, subsets=hits);
    gt.res<-result(gt.obj);
    set.num<-unlist(lapply(current.mset, length), use.names = FALSE);


    match.num <- gt.res[,5];
    if(sum(match.num>0)==0){
        AddErrMsg("No match was found to the selected metabolite set library!");
        return(0);
    }

    raw.p <- gt.res[,1];

    # add adjust p values
    bonf.p <- p.adjust(raw.p, "holm");
    fdr.p <- p.adjust(raw.p, "fdr");

    res.mat <- cbind(set.num, match.num, gt.res[,2], gt.res[,3], raw.p, bonf.p, fdr.p);
    rownames(res.mat)<-rownames(gt.res);
    colnames(res.mat)<-c("Total Cmpd", "Hits", "Statistic Q", "Expected Q", "Raw p", "Holm p", "FDR");

    hit.inx<-res.mat[,2]>0;
    res.mat<-res.mat[hit.inx, ];
	ord.inx<-order(res.mat[,5]);
    res.mat<-res.mat[ord.inx,];

    analSet$qea.msea <<- gt.obj;
    analSet$qea.mat <<- signif(res.mat,5);
    analSet$qea.hits <<- hits;
    gc();
    write.csv(analSet$qea.mat, file="msea_qea_result.csv");
    return(1);
}

GetQEA.colorBar<-function(){
    len <- nrow(analSet$qea.mat);
    if(len > 50){
        ht.col <- c(substr(heat.colors(50), 0, 7), rep("#FFFFFF", len-50));
    }else{
        # reduce to hex by remove the last character so HTML understand
        ht.col <- substr(heat.colors(len), 0, 7);
    }
    return (ht.col);
}

GetQEA.rowNames<-function(){
    nms <- rownames(analSet$qea.mat);
    if(is.null(nms)){
        return("NA");
    }
    return (nms);
}

GetQEA.mat<-function(){
    return(analSet$qea.mat);
}

GetQEATable<-function(){
    library(xtable);
    res <- analSet$qea.mat;
    if(substr(analSet$type, 0, 4) == 'mset'){
        print(xtable(res,align="p{4cm}|l|l|l|l|l|l|l", display=c("s","d","d","f","f","E","E","E"),
            caption="Result from Quantitative Enrichment Analysis"),
            tabular.environment = "longtable", caption.placement="top", size="\\scriptsize");
    }else{
        rownames(res)<- GetQEA.pathNames();
        print(xtable(res,align="p{5cm}|l|l|l|l|l|l|l", display=c("s","d","d","E","E", "E","E","f"),
            caption="Result from Pathway Analysis"),
            tabular.environment = "longtable", caption.placement="top", size="\\scriptsize");
    }
}

############################################
# single sample profiling to compare with
# reference concentrations stored in the library
############################################
CalculateSSP<-function(){

       # first update the compound name to hmdb valid name
       nm.map <- GetFinalNameMap();

       valid.inx <- !(is.na(nm.map$hmdb)|duplicated(nm.map$hmdb));
       nm.map <- nm.map[valid.inx,];
       orig.nms <- nm.map$query;

       hmdb.inx <- match(dataSet$cmpd,orig.nms);
       match.inx <- !is.na(hmdb.inx);

       # note, must use "as.character" since string column from data frame will be converted to factors
       # when they used with numerics, they will be changed to numbers, not string
       ssp.nm <- as.character(nm.map$hmdb[hmdb.inx[match.inx]]);
       ssp.vec <- dataSet$norm[match.inx];

       cmpd.db <- readRDS("../../libs/compound_db.rds");
       hit.inx <- match(tolower(ssp.nm), tolower(cmpd.db$name));

       # create the result mat
       res.mat<-matrix("NA", nrow=length(ssp.nm), ncol=6);
       colnames(res.mat)<-c("name","conc", "hmdb", "refs", "state", "details");

       ssp.lows <- list();
       ssp.highs <- list();
       ssp.means <- list();
       ssp.refs <- list();
       ssp.pmids <- list();
       ssp.notes <- list();
       for(i in 1:length(ssp.nm)){
            inx <- hit.inx[i];
            if(is.na(inx)){ # no match to HMDB ID
                res.mat[i, ]<-c(ssp.nm[i],ssp.vec[i], "--", "--", "--", "");
                ssp.lows[[i]]<-NA;
                ssp.highs[[i]]<-NA;
                ssp.means[[i]]<-NA;
                ssp.refs[[i]]<-NA;
                ssp.pmids[[i]]<-NA;
                ssp.notes[[i]] <- NA;
            }else{
                hits <- Get.ConcRef(ssp.nm[i]);
                if(is.na(hits)){ # no conc info
                    res.mat[i, ]<-c(ssp.nm[i], ssp.vec[i], cmpd.db$hmdb[inx], "--", "--", "");
                    ssp.lows[[i]]<-NA;
                    ssp.highs[[i]]<-NA;
                    ssp.means[[i]]<-NA;
                    ssp.refs[[i]]<-NA;
                    ssp.pmids[[i]]<-NA;
                    ssp.notes[[i]] <- NA;
                }else{ # concentration info
                    concs<-as.numeric(unlist(strsplit(hits$conc, " - "), use.names = FALSE));
                    pmid <- hits$pmid;
                    refs <- hits$refs;

                    low.inx<-seq(1,length(concs)-2, 3);
                    mean.inx<-seq(2,length(concs)-1, 3);
                    high.inx<-seq(3,length(concs), 3);
                    low.conc<-concs[low.inx];
                    mean.conc <-concs[mean.inx];
                    high.conc<-concs[high.inx];
                    conc.show <- paste(mean.conc, " (", low.conc, " - ", high.conc, ")", sep="", collapse="; ");

                    ssp.lows[[i]]<-low.conc;
                    ssp.means[[i]]<-mean.conc;
                    ssp.highs[[i]]<-high.conc;
                    ssp.refs[[i]]<-hits$refs;
                    ssp.pmids[[i]]<-hits$pmid;
                    if(is.na(hits$note)){
                        ssp.notes[[i]] <- NA;
                    }else{
                        ssp.notes[[i]] <- hits$note;
                    }
                    state <- NULL;
                    if(ssp.vec[i]<min(low.conc)){
                        state = "L";
                    }else if(ssp.vec[i]>max(high.conc)){
                        state = "H";
                    }else{
                        state = "M";
                    }
                    res.mat[i, ]<-c(ssp.nm[i], ssp.vec[i], cmpd.db$hmdb[inx], conc.show, state, "View");
                }
            }
       }

       analSet$ssp.highs <<- ssp.highs;
       analSet$ssp.lows <<- ssp.lows;
       analSet$ssp.means <<- ssp.means;
       analSet$ssp.refs <<- ssp.refs;
       analSet$ssp.pmids <<- ssp.pmids;
       analSet$ssp.notes <<- ssp.notes;
       analSet$ssp.mat <<- res.mat;
}


GetSSP.Names<-function(){
    return(analSet$ssp.mat[,1]);
}

# measured concentration
GetSSP.Concs<-function(){
    return(analSet$ssp.mat[,2]);
}

GetSSP.HMDB<-function(){
    return(analSet$ssp.mat[,3]);
}

GetSSP.RefConcs<-function(){
    return(analSet$ssp.mat[,4]);
}

GetSSP.States<-function(){
    return(analSet$ssp.mat[,5]);
}

GetSSP.Details<-function(){
    return(analSet$ssp.mat[,6]);
}

GetSSP.NameLink<-function(inx){
     return(paste("<a href=\"http://www.hmdb.ca/metabolites/", analSet$ssp.mat[inx,3], "\">", analSet$ssp.mat[inx,1], "</a>", sep=""));
}

GetSSP.RefConc<-function(inx){
    if(is.na(analSet$ssp.means[[inx]])){
        return ("NA");
    }
    return(paste(analSet$ssp.means[[inx]], " (", analSet$ssp.lows[[inx]], " - ", analSet$ssp.highs[[inx]], ")", sep=""));
}

GetSSP.Refs<-function(inx){
    return(analSet$ssp.refs[[inx]]);
}

GetSSP.Pmids<-function(inx){
    return(analSet$ssp.pmids[[inx]]);
}

GetSSP.Notes<-function(inx){
    return(analSet$ssp.notes[[inx]]);
}

# replace last column of the ssp.mat with the final selection from users
GetSSPTable<-function(){
    library(xtable);
    ssp.res<-analSet$ssp.mat[,-c(1,3,6)];
    rownames(ssp.res)<-analSet$ssp.mat[,1]
    selected.col<-rep(0, nrow(ssp.res));
    inx<-match(dataSet$cmpd, analSet$ssp.mat[,1]);
    selected.col[inx]<-1;
    print(xtable(cbind(ssp.res, selected = selected.col),align="l|l|p{8cm}|c|c", caption="Comparison with Reference Concentrations"),
          tabular.environment = "longtable", caption.placement="top", size="\\scriptsize");
}

# given a metset inx, return hmtl highlighted metset cmpds and references
GetHTMLMetSet<-function(msetInx){
    hits <- NULL;
    if(analSet$type=="msetora" || analSet$type=="msetssp"){
        msetNm <- rownames(analSet$ora.mat)[msetInx];
        hits <- analSet$ora.hits;
    }else{
        msetNm <- rownames(analSet$qea.mat)[msetInx];
        hits <- analSet$qea.hits;
    }

    # highlighting with different colors
    mset <- current.mset[[msetNm]];
    red.inx <- which(mset %in% hits[[msetNm]]);
    mset[red.inx] <- paste("<font color=\"red\">", "<b>", mset[red.inx], "</b>", "</font>",sep="");
    if(use.metabo.filter && exists('filtered.mset')){
        grey.inx <- which(!(mset %in% filtered.mset[[msetNm]]));
        mset[grey.inx] <- paste("<font color=\"grey\">", "<b>", mset[grey.inx], "</b>", "</font>",sep="");
    }

    # get references
    matched.inx <- match(tolower(msetNm), tolower(current.msetlib$name))[1];
    return(cbind(msetNm, paste(mset, collapse="; "), current.msetlib$reference[matched.inx]));
}

# given a metset inx, give its name
GetMetSetName<-function(msetInx){
    if(analSet$type=="msetora" || analSet$type=="msetssp"){
        msetNm <- rownames(analSet$ora.mat)[msetInx];
    }else{
        msetNm <- rownames(analSet$qea.mat)[msetInx];
    }
    return (msetNm);
}

